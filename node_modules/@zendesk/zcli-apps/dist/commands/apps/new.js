"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const fileUtils_1 = require("../../utils/fileUtils");
const manifest_1 = require("../../utils/manifest");
const fs = require("fs");
const fsExtra = require("fs-extra");
const https = require("https");
const path = require("path");
const AdmZip = require("adm-zip");
const chalk = require("chalk");
const errors_1 = require("@oclif/core/lib/errors");
class New extends core_1.Command {
    constructor() {
        super(...arguments);
        this.zipScaffoldPath = path.join(process.cwd(), 'scaffold.zip');
        this.unzippedScaffoldPath = path.join(process.cwd(), 'app_scaffolds-master');
        this.EMAIL_REGEX = /^.+@.+\..+$/;
        this.URL_REGEX = /^http(s)?:\/\/?[\w.-]+(?:\.[\w-]+)+[\w\-_~:/?#[\]@!&',;=.]+$/;
    }
    async downloadScaffoldsRepo(url) {
        return new Promise((resolve, reject) => {
            const destination = fs.createWriteStream(this.zipScaffoldPath);
            https.get(url, (response) => {
                response.pipe(destination);
            });
            destination.on('finish', () => {
                const zip = new AdmZip(this.zipScaffoldPath);
                const overwrite = false;
                zip.extractAllToAsync(path.join(process.cwd()), overwrite, true, async (err) => {
                    await (0, fileUtils_1.cleanDirectory)(this.zipScaffoldPath);
                    if (err) {
                        reject(err);
                    }
                    resolve();
                });
            });
        });
    }
    async extractScaffoldIfExists(flagScaffold, directoryName) {
        return new Promise((resolve, reject) => {
            fsExtra.copy(path.join(process.cwd(), '/', 'app_scaffolds-master/packages/', flagScaffold), path.join(process.cwd(), directoryName), { overwrite: true, errorOnExist: true }, async (err) => {
                await (0, fileUtils_1.cleanDirectory)(this.unzippedScaffoldPath);
                if (err) {
                    const fsExtraError = err;
                    if (fsExtraError.code === 'ENOENT') {
                        reject(new Error(`Scaffold ${flagScaffold} does not exist: ${err}`));
                    }
                    reject(err);
                }
                resolve();
            });
        });
    }
    modifyManifest(directoryName, appName, authorName, authorEmail, flagScaffold, authorURL) {
        const manifestPath = {
            basic: path.join(process.cwd(), directoryName),
            react: path.join(process.cwd(), directoryName, 'src')
        };
        const manifest = (0, manifest_1.getManifestFile)(manifestPath[flagScaffold]);
        manifest.name = appName;
        manifest.author.name = authorName;
        manifest.author.email = authorEmail;
        if (authorURL === null || authorURL === void 0 ? void 0 : authorURL.trim()) {
            manifest.author.url = authorURL;
        }
        else {
            delete manifest.author.url;
        }
        (0, manifest_1.updateManifestFile)(manifestPath[flagScaffold], manifest);
    }
    async run() {
        const { flags } = await this.parse(New);
        const flagScaffold = flags.scaffold;
        const directoryName = flags.path || await core_1.CliUx.ux.prompt('Enter a directory name to save the new app (will create the dir if it does not exist)');
        const authorName = flags.authorName || await core_1.CliUx.ux.prompt('Enter this app authors name');
        let authorEmail = flags.authorEmail || await core_1.CliUx.ux.prompt('Enter this app authors email');
        while (!this.EMAIL_REGEX.test(authorEmail)) {
            console.log(chalk.red('Invalid email, please try again'));
            authorEmail = flags.authorEmail || await core_1.CliUx.ux.prompt('Enter this app authors email');
        }
        let authorURL = flags.authorURL || await core_1.CliUx.ux.prompt('Enter this app authors website (optional)', { required: false });
        while (authorURL.trim() && !this.URL_REGEX.test(authorURL)) {
            console.log(chalk.red('Invalid URL. Please make sure your website begins with "http://" or "https://" and try again (Enter to skip)'));
            authorURL = await core_1.CliUx.ux.prompt('Enter this apps URL', { required: false });
        }
        const appName = flags.appName || await core_1.CliUx.ux.prompt('Enter a name for this new app');
        const scaffoldUrl = 'https://codeload.github.com/zendesk/app_scaffolds/zip/master';
        try {
            await this.downloadScaffoldsRepo(scaffoldUrl);
            await this.extractScaffoldIfExists(flagScaffold, directoryName);
        }
        catch (err) {
            throw new errors_1.CLIError(chalk.red(`Download of scaffold structure failed with error: ${err}`));
        }
        this.modifyManifest(directoryName, appName, authorName, authorEmail, flagScaffold, authorURL);
        console.log(chalk.green(`Successfully created new project ${directoryName}`));
    }
}
exports.default = New;
New.description = 'generates a bare bones app locally for development';
New.flags = {
    scaffold: core_1.Flags.string({ default: 'basic', description: 'Choose from open-source Zendesk app scaffold structures' }),
    path: core_1.Flags.string({ description: 'Path of your new app' }),
    authorName: core_1.Flags.string({ description: 'Name of app author' }),
    authorEmail: core_1.Flags.string({ description: 'Email of app author' }),
    appName: core_1.Flags.string({ description: 'Name of the app' }),
    authorURL: core_1.Flags.string({ description: 'URL of the app author' })
};
New.examples = [
    '$ zcli apps:new',
    '$ zcli apps:new --scaffold=basic',
    '$ zcli apps:new --scaffold=react'
];
